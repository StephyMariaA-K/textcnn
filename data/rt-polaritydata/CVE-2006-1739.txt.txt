 diff
 -
 u
 -
8
 -
 p
 -
r3.263
 nsCSSRendering.cpp
 -
 -
 -
 a
 /
 layout
 /
 base
 /
nsCSSRendering.cpp	2
 Aug
2005
20
:11
:09
 -
0000
	3
.263
 +
 +
 +
 b
 /
 layout
 /
 base
 /
nsCSSRendering.cpp	1
 Nov
2005
19
:44
:57
 -
0000
 -
3626
 ,
20
 +
3626
 ,
24
 nsCSSRendering::RenderSide
 (
 nsFloatPoint
 case
 NS_STYLE_BORDER_STYLE_AUTO:
 case
 NS_STYLE_BORDER_STYLE_SOLID:
polypath[0
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
polypath[0
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
 curIndex
=
1
 ;
 GetPath
 (
 aPoints
 ,
 polypath
 ,
 &
 curIndex
 ,
 eOutside
 ,
 c1Index
 )
 ;
 c2Index
=
 curIndex
 ;
 +
 if
 (
 curIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 polypath[curIndex].x
=
 NSToCoordRound
 (
aPoints[6
 )
 ;
 polypath[curIndex].y
=
 NSToCoordRound
 (
aPoints[6
 )
 ;
 curIndex
 +
 +
 ;
 GetPath
 (
 aPoints
 ,
 polypath
 ,
 &
 curIndex
 ,
 eInside
 ,
 junk
 )
 ;
 +
 if
 (
 curIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 polypath[curIndex].x
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
 polypath[curIndex].y
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
 curIndex
 +
 +
 ;
 aRenderingContext.FillPolygon
 (
 polypath
 ,
 curIndex
 )
 ;
 break
 ;
 case
 NS_STYLE_BORDER_STYLE_DOUBLE:
polypath[0
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
 -
3661
 ,
39
 +
3665
 ,
47
 nsCSSRendering::RenderSide
 (
 nsFloatPoint
 {
 const
 nsStyleBackground
 *
 bgColor
=
 nsCSSRendering::FindNonTransparentBackground
 (
 aStyleContext
 )
 ;
 aRenderingContext.SetColor
 (
 MakeBevelColor
 (
 aSide
 ,
 border_Style
 ,
 bgColor
 -
 >
 BackgroundColor
 ,
 sideColor
 ,
 PR_TRUE
 )
 )
 ;
polypath[0
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
polypath[0
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
 curIndex
=
1
 ;
 GetPath
 (
 aPoints
 ,
 polypath
 ,
 &
 curIndex
 ,
 eOutside
 ,
 c1Index
 )
 ;
 +
 if
 (
 curIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 polypath[curIndex].x
=
 NSToCoordRound
 (
 (
aPoints[5
 +
aPoints[6
 )
 /
2
.0
 f
 )
 ;
 polypath[curIndex].y
=
 NSToCoordRound
 (
 (
aPoints[5
 +
aPoints[6
 )
 /
2
.0
 f
 )
 ;
 curIndex
 +
 +
 ;
 GetPath
 (
 aPoints
 ,
 polypath
 ,
 &
 curIndex
 ,
 eCalcRev
 ,
 c1Index
 ,
.5
 )
 ;
 +
 if
 (
 curIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 polypath[curIndex].x
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
 polypath[curIndex].y
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
 curIndex
 +
 +
 ;
 aRenderingContext.FillPolygon
 (
 polypath
 ,
 curIndex
 )
 ;
 aRenderingContext.SetColor
 (
 MakeBevelColor
 (
 aSide
 ,
 (
 (
 border_Style
 ==
 NS_STYLE_BORDER_STYLE_RIDGE
 )
 NS_STYLE_BORDER_STYLE_GROOVE
 NS_STYLE_BORDER_STYLE_RIDGE
 )
 ,
 bgColor
 -
 >
 BackgroundColor
 ,
 sideColor
 ,
 PR_TRUE
 )
 )
 ;
polypath[0
=
 NSToCoordRound
 (
 (
aPoints[0
 +
aPoints[11
 )
 /
2
.0
 f
 )
 ;
polypath[0
=
 NSToCoordRound
 (
 (
aPoints[0
 +
aPoints[11
 )
 /
2
.0
 f
 )
 ;
 curIndex
=
1
 ;
 GetPath
 (
 aPoints
 ,
 polypath
 ,
 &
 curIndex
 ,
 eCalc
 ,
 c1Index
 ,
.5
 )
 ;
 +
 if
 (
 curIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 polypath[curIndex].x
=
 NSToCoordRound
 (
aPoints[6
 )
 ;
 polypath[curIndex].y
=
 NSToCoordRound
 (
aPoints[6
 )
 ;
 curIndex
 +
 +
 ;
 GetPath
 (
 aPoints
 ,
 polypath
 ,
 &
 curIndex
 ,
 eInside
 ,
 c1Index
 )
 ;
 +
 if
 (
 curIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 polypath[curIndex].x
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
 polypath[curIndex].y
=
 NSToCoordRound
 (
aPoints[0
 )
 ;
 curIndex
 +
 +
 ;
 aRenderingContext.FillPolygon
 (
 polypath
 ,
 curIndex
 )
 ;
 }
 break
 ;
 default:
 break
 ;
 -
3874
 ,
95
 +
3886
 ,
122
 RoundedRect::GetRoundedBorders
 (
 QBCurve
 &
 *
 aCurIndex
 -
 -
 the
 index
 that
 points
 to
 the
 last
 element
 of
 the
 array
 *
 aPathType
 -
 -
 what
 kind
 of
 path
 that
 should
 be
 returned
 *
 aFrac
 -
 -
 the
 inset
 amount
 for
 a
 eCalc
 type
 path
 *
 /
 static
 void
 GetPath
 (
 nsFloatPoint
 aPoints[]
 ,
 nsPoint
 aPolyPath[]
 ,
PRInt32
 *
 aCurIndex
 ,
 ePathTypes
 aPathType
 ,
PRInt32
 &
 aC1Index
 ,
 float
 aFrac
 )
 {
 QBCurve
 thecurve
 ;
 +
 +
 if
 (
 *
 aCurIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 switch
 (
 aPathType
 )
 {
 case
 eOutside:
 thecurve.SetPoints
 (
aPoints[0
 ,
aPoints[0
 ,
aPoints[1
 ,
aPoints[1
 ,
aPoints[2
 ,
aPoints[2
 )
 ;
 thecurve.SubDivide
 (
 nsnull
 ,
 aPolyPath
 ,
 aCurIndex
 )
 ;
 aC1Index
=
 *
 aCurIndex
 ;
 +
 if
 (
 *
 aCurIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 aPolyPath[
 *
 aCurIndex].x
=
 (
 nscoord
 )
aPoints[3
 ;
 aPolyPath[
 *
 aCurIndex].y
=
 (
 nscoord
 )
aPoints[3
 ;
 (
 *
 aCurIndex
 )
 +
 +
 ;
 +
 if
 (
 *
 aCurIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 thecurve.SetPoints
 (
aPoints[3
 ,
aPoints[3
 ,
aPoints[4
 ,
aPoints[4
 ,
aPoints[5
 ,
aPoints[5
 )
 ;
 thecurve.SubDivide
 (
 nsnull
 ,
 aPolyPath
 ,
 aCurIndex
 )
 ;
 break
 ;
 case
 eInside:
 thecurve.SetPoints
 (
aPoints[6
 ,
aPoints[6
 ,
aPoints[7
 ,
aPoints[7
 ,
aPoints[8
 ,
aPoints[8
 )
 ;
 thecurve.SubDivide
 (
 nsnull
 ,
 aPolyPath
 ,
 aCurIndex
 )
 ;
 +
 if
 (
 *
 aCurIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 aPolyPath[
 *
 aCurIndex].x
=
 (
 nscoord
 )
aPoints[9
 ;
 aPolyPath[
 *
 aCurIndex].y
=
 (
 nscoord
 )
aPoints[9
 ;
 (
 *
 aCurIndex
 )
 +
 +
 ;
 +
 if
 (
 *
 aCurIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 thecurve.SetPoints
 (
aPoints[9
 ,
aPoints[9
 ,
aPoints[10
 ,
aPoints[10
 ,
aPoints[11
 ,
aPoints[11
 )
 ;
 thecurve.SubDivide
 (
 nsnull
 ,
 aPolyPath
 ,
 aCurIndex
 )
 ;
 break
 ;
 case
 eCalc:
 thecurve.SetPoints
 (
 (
aPoints[0
 +
aPoints[11
 )
 /
2
.0
 f
 ,
 (
aPoints[0
 +
aPoints[11
 )
 /
2
.0
 f
 ,
 (
aPoints[1
 +
aPoints[10
 )
 /
2
.0
 f
 ,
 (
aPoints[1
 +
aPoints[10
 )
 /
2
.0
 f
 ,
 (
aPoints[2
 +
aPoints[9
 )
 /
2
.0
 f
 ,
 (
aPoints[2
 +
aPoints[9
 )
 /
2
.0
 f
 )
 ;
 thecurve.SubDivide
 (
 nsnull
 ,
 aPolyPath
 ,
 aCurIndex
 )
 ;
 +
 if
 (
 *
 aCurIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 aPolyPath[
 *
 aCurIndex].x
=
 (
 nscoord
 )
 (
 (
aPoints[3
 +
aPoints[8
 )
 /
2
.0
 f
 )
 ;
 aPolyPath[
 *
 aCurIndex].y
=
 (
 nscoord
 )
 (
 (
aPoints[3
 +
aPoints[8
 )
 /
2
.0
 f
 )
 ;
 (
 *
 aCurIndex
 )
 +
 +
 ;
 +
 if
 (
 *
 aCurIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 thecurve.SetPoints
 (
 (
aPoints[3
 +
aPoints[8
 )
 /
2
.0
 f
 ,
 (
aPoints[3
 +
aPoints[8
 )
 /
2
.0
 f
 ,
 (
aPoints[4
 +
aPoints[7
 )
 /
2
.0
 f
 ,
 (
aPoints[4
 +
aPoints[7
 )
 /
2
.0
 f
 ,
 (
aPoints[5
 +
aPoints[6
 )
 /
2
.0
 f
 ,
 (
aPoints[5
 +
aPoints[6
 )
 /
2
.0
 f
 )
 ;
 thecurve.SubDivide
 (
 nsnull
 ,
 aPolyPath
 ,
 aCurIndex
 )
 ;
 break
 ;
 case
 eCalcRev:
 thecurve.SetPoints
 (
 (
aPoints[5
 +
aPoints[6
 )
 /
2
.0
 f
 ,
 (
aPoints[5
 +
aPoints[6
 )
 /
2
.0
 f
 ,
 (
aPoints[4
 +
aPoints[7
 )
 /
2
.0
 f
 ,
 (
aPoints[4
 +
aPoints[7
 )
 /
2
.0
 f
 ,
 (
aPoints[3
 +
aPoints[8
 )
 /
2
.0
 f
 ,
 (
aPoints[3
 +
aPoints[8
 )
 /
2
.0
 f
 )
 ;
 thecurve.SubDivide
 (
 nsnull
 ,
 aPolyPath
 ,
 aCurIndex
 )
 ;
 aPolyPath[
 *
 aCurIndex].x
=
 (
 nscoord
 )
 (
 (
aPoints[2
 +
aPoints[9
 )
 /
2
.0
 f
 )
 ;
 aPolyPath[
 *
 aCurIndex].y
=
 (
 nscoord
 )
 (
 (
aPoints[2
 +
aPoints[9
 )
 /
2
.0
 f
 )
 ;
 (
 *
 aCurIndex
 )
 +
 +
 ;
 +
 if
 (
 *
 aCurIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 thecurve.SetPoints
 (
 (
aPoints[2
 +
aPoints[9
 )
 /
2
.0
 f
 ,
 (
aPoints[2
 +
aPoints[9
 )
 /
2
.0
 f
 ,
 (
aPoints[1
 +
aPoints[10
 )
 /
2
.0
 f
 ,
 (
aPoints[1
 +
aPoints[10
 )
 /
2
.0
 f
 ,
 (
aPoints[0
 +
aPoints[11
 )
 /
2
.0
 f
 ,
 (
aPoints[0
 +
aPoints[11
 )
 /
2
.0
 f
 )
 ;
 thecurve.SubDivide
 (
 nsnull
 ,
 aPolyPath
 ,
 aCurIndex
 )
 ;
 break
 ;
 }
 }
 void
 QBCurve::SubDivide
 (
 nsIRenderingContext
 *
 aRenderingContext
 ,
 nsPoint
 aPointArray[]
 ,
PRInt32
 *
 aCurIndex
 )
 {
 -
 QBCurve
 curve1
 ,
 curve2
 ;
 -
 float
 fx
 ,
 fy
 ,
 smag
 ;
 -
 +
 QBCurve
 curve1
 ,
 curve2
 ;
 +
 float
 fx
 ,
 fy
 ,
 smag
 ,
 oldfx
 ,
 oldfy
 ,
 oldsmag
 ;
 +
 +
 if
 (
 *
 aCurIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 +
 +
 oldfx
=
 (
 this
 -
 >
 Anc1.x
 +
 this
 -
 >
 Anc2.x
 )
 /
2
.0
 f
 -
 this
 -
 >
 Con.x
 ;
 +
 oldfy
=
 (
 this
 -
 >
 Anc1.y
 +
 this
 -
 >
 Anc2.y
 )
 /
2
.0
 f
 -
 this
 -
 >
 Con.y
 ;
 +
 oldsmag
=
 oldfx
 *
 oldfx
 +
 oldfy
 *
 oldfy
 ;
 MidPointDivide
 (
 &
 curve1
 ,
 &
 curve2
 )
 ;
 fx
=
 (
 float
 )
 fabs
 (
 curve1.mAnc2.x
 -
 this
 -
 >
 Con.x
 )
 ;
 fy
=
 (
 float
 )
 fabs
 (
 curve1.mAnc2.y
 -
 this
 -
 >
 Con.y
 )
 ;
 smag
=
 fx
 *
 fx
 +
 fy
 *
 fy
 ;
 if
 (
 smag>
 )
 {
 +
 if
 (
 smag
 +
0
.2
 >
 oldsmag
 )
 +
 return
 ;
 curve1.SubDivide
 (
 aRenderingContext
 ,
 aPointArray
 ,
 aCurIndex
 )
 ;
 curve2.SubDivide
 (
 aRenderingContext
 ,
 aPointArray
 ,
 aCurIndex
 )
 ;
 }
 else
 {
 if
 (
 aPointArray
 )
 {
 aPointArray[
 *
 aCurIndex].x
=
 (
 nscoord
 )
 curve1.mAnc2.x
 ;
 aPointArray[
 *
 aCurIndex].y
=
 (
 nscoord
 )
 curve1.mAnc2.y
 ;
 (
 *
 aCurIndex
 )
 +
 +
 ;
 +
 if
 (
 *
 aCurIndex
 >=
 MAXPOLYPATHSIZE
 )
 +
 return
 ;
 aPointArray[
 *
 aCurIndex].x
=
 (
 nscoord
 )
 curve2.mAnc2.x
 ;
 aPointArray[
 *
 aCurIndex].y
=
 (
 nscoord
 )
 curve2.mAnc2.y
 ;
 (
 *
 aCurIndex
 )
 +
 +
 ;
 }
 else
 {
 nsTransform2D
 *
 aTransform
 ;
 aRenderingContext
 -
 >
 etCurrentTransform
 (
 aTransform
 )
 ;
