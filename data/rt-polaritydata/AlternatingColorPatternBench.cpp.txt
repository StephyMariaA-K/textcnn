 enum
 ColorPattern
 {
 kWhite_ColorPattern
 ,
 kBlue_ColorPattern
 ,
 kOpaqueBitmap_ColorPattern
 ,
 kAlphaBitmap_ColorPattern
 ,
 }
 ;
 static
 const
 struct
 ColorPatternData
 {
 SkColor
 fColor
 ;
 bool
 fIsBitmap
 ;
 const
 char
 *
 fName
 ;
 }
 gColorPatterns[]
=
 {
 {
 SK_ColorWHITE
 ,
 false
 ,
"white"
 }
 ,
 {
 SK_ColorBLUE
 ,
 false
 ,
"blue"
 }
 ,
 {
 SK_ColorWHITE
 ,
 true
 ,
"obaqueBitMap"
 }
 ,
 {
0
x10000000
 ,
 true
 ,
"alphaBitmap"
 }
 ,
 }
 ;
 enum
 DrawType
 {
 kRect_DrawType
 ,
 kPath_DrawType
 ,
 }
 ;
 static
 void
 makebm
 (
 SkBitmap
 *
 bm
 ,
 int
 w
 ,
 int
 h
 )
 {
 bm
 -
 >
llocN32
 Pixels
 (
 w
 ,
 h
 )
 ;
 bm
 -
 >
 raseColor
 (
 SK_ColorTRANSPARENT
 )
 ;
 SkCanvas
 canvas
 (
 *
 bm
 )
 ;
 SkScalar
 s
=
 SkIntToScalar
 (
SkMin32
 (
 w
 ,
 h
 )
 )
 ;
 static
 const
 SkPoint
 kPts0[]
=
 {
 {
0
 ,
0
 }
 ,
 {
 s
 ,
 s
 }
 }
 ;
 static
 const
 SkPoint
 kPts1[]
=
 {
 {
 s
 /
2
 ,
0
 }
 ,
 {
 s
 /
2
 ,
 s
 }
 }
 ;
 static
 const
 SkScalar
 kPos[]
=
 {
0
 ,
 SK_Scalar1
 /
2
 ,
 SK_Scalar1
 }
 ;
 static
 const
 SkColor
 kColors0[]
=
 {
0
x80
F00080
 ,
0
xF0F08000
 ,
0
x800080
 F0
 }
 ;
 static
 const
 SkColor
 kColors1[]
=
 {
0
xF08000
 F0
 ,
0
x8080
F000
 ,
0
xF000
F080
 }
 ;
 SkPaint
 paint
 ;
 paint.setShader
 (
 SkGradientShader::MakeLinear
 (
 kPts0
 ,
 kColors0
 ,
 kPos
 ,
 SK_ARRAY_COUNT
 (
 kColors0
 )
 ,
 SkShader::kClamp_TileMode
 )
 )
 ;
 canvas.drawPaint
 (
 paint
 )
 ;
 paint.setShader
 (
 SkGradientShader::MakeLinear
 (
 kPts1
 ,
 kColors1
 ,
 kPos
 ,
 SK_ARRAY_COUNT
 (
 kColors1
 )
 ,
 SkShader::kClamp_TileMode
 )
 )
 ;
 canvas.drawPaint
 (
 paint
 )
 ;
 }
 class
 AlternatingColorPatternBench
 public
 Benchmark
 {
 public:
 enum
 {
 NX
=
5
 ,
 NY
=
5
 ,
 NUM_DRAWS
=
 NX
 *
 NY
 ,
 }
 ;
 sk_sp<
 kShader>
 fBmShader
 ;
 SkPath
 fPaths[NUM_DRAWS]
 ;
 SkRect
 fRects[NUM_DRAWS]
 ;
 SkColor
 fColors[NUM_DRAWS]
 ;
 sk_sp<
 kShader>
 fShaders[NUM_DRAWS]
 ;
 SkString
 fName
 ;
 ColorPatternData
 fPattern1
 ;
 ColorPatternData
 fPattern2
 ;
 DrawType
 fDrawType
 ;
 SkBitmap
 fBmp
 ;
 AlternatingColorPatternBench
 (
 ColorPattern
 pattern1
 ,
 ColorPattern
 pattern2
 ,
 DrawType
 drawType
 )
 {
 fPattern1
=
 gColorPatterns[pattern1]
 ;
 fPattern2
=
 gColorPatterns[pattern2]
 ;
 fName.printf
 (
"colorPattern_%s_%s_%s"
 ,
 fPattern1.fName
 ,
 fPattern2.fName
 ,
 kRect_DrawType
 ==
 drawType
"rect"
"path"
 )
 ;
 fDrawType
=
 drawType
 ;
 }
 protected:
 const
 char
 *
 onGetName
 (
 )
 override
 {
 return
 fName.c_str
 (
 )
 ;
 }
 void
 onDelayedSetup
 (
 )
 override
 {
 int
 w
=
40
 ;
 int
 h
=
40
 ;
 makebm
 (
 &
 fBmp
 ,
 w
 ,
 h
 )
 ;
 fBmShader
=
 SkShader::MakeBitmapShader
 (
 fBmp
 ,
 SkShader::kRepeat_TileMode
 ,
 SkShader::kRepeat_TileMode
 )
 ;
 int
 offset
=
2
 ;
 int
 count
=
0
 ;
 for
 (
 int
 j
=
0
 ;
 j
 <
 NY
 ;
 +
 +
 j
 )
 {
 for
 (
 int
 i
=
0
 ;
 i
 <
 NX
 ;
 +
 +
 i
 )
 {
 int
 x
=
 (
 w
 +
 offset
 )
 *
 i
 ;
 int
 y
=
 (
 h
 *
 offset
 )
 *
 j
 ;
 if
 (
 kRect_DrawType
 ==
 fDrawType
 )
 {
 fRects[count].set
 (
 SkIntToScalar
 (
 x
 )
 ,
 SkIntToScalar
 (
 y
 )
 ,
 SkIntToScalar
 (
 x
 +
 w
 )
 ,
 SkIntToScalar
 (
 y
 +
 h
 )
 )
 ;
 }
 else
 {
 fPaths[count].moveTo
 (
 SkIntToScalar
 (
 x
 )
 ,
 SkIntToScalar
 (
 y
 )
 )
 ;
 fPaths[count].rLineTo
 (
 SkIntToScalar
 (
 w
 )
 ,
0
 )
 ;
 fPaths[count].rLineTo
 (
0
 ,
 SkIntToScalar
 (
 h
 )
 )
 ;
 fPaths[count].rLineTo
 (
 SkIntToScalar
 (
 -
 w
 +
1
 )
 ,
0
 )
 ;
 }
 if
 (
0
 ==
 count
2
 )
 {
 fColors[count]
=
 fPattern1.fColor
 ;
 fShaders[count]
=
 fPattern1.fIsBitmap
 fBmShader
 nullptr
 ;
 }
 else
 {
 fColors[count]
=
 fPattern2.fColor
 ;
 fShaders[count]
=
 fPattern2.fIsBitmap
 fBmShader
 nullptr
 ;
 }
 +
 +
 count
 ;
 }
 }
 }
 void
 onDraw
 (
 int
 loops
 ,
 SkCanvas
 *
 canvas
 )
 override
 {
 SkPaint
 paint
 ;
 paint.setAntiAlias
 (
 false
 )
 ;
 paint.setFilterQuality
 (
 kLow_SkFilterQuality
 )
 ;
 for
 (
 int
 i
=
0
 ;
 i
 <
 loops
 ;
 +
 +
 i
 )
 {
 for
 (
 int
 j
=
0
 ;
 j
 <
 NUM_DRAWS
 ;
 +
 +
 j
 )
 {
 paint.setColor
 (
 fColors[j]
 )
 ;
 paint.setShader
 (
 fShaders[j]
 )
 ;
 if
 (
 kRect_DrawType
 ==
 fDrawType
 )
 {
 canvas
 -
 >
 rawRect
 (
 fRects[j]
 ,
 paint
 )
 ;
 }
 else
 {
 canvas
 -
 >
 rawPath
 (
 fPaths[j]
 ,
 paint
 )
 ;
 }
 }
 }
 }
 private:
 typedef
 Benchmark
 INHERITED
 ;
 }
 ;
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kWhite_ColorPattern
 ,
 kWhite_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kBlue_ColorPattern
 ,
 kBlue_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kWhite_ColorPattern
 ,
 kBlue_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kOpaqueBitmap_ColorPattern
 ,
 kOpaqueBitmap_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kAlphaBitmap_ColorPattern
 ,
 kAlphaBitmap_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kOpaqueBitmap_ColorPattern
 ,
 kAlphaBitmap_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kOpaqueBitmap_ColorPattern
 ,
 kOpaqueBitmap_ColorPattern
 ,
 kRect_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kAlphaBitmap_ColorPattern
 ,
 kAlphaBitmap_ColorPattern
 ,
 kRect_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kOpaqueBitmap_ColorPattern
 ,
 kAlphaBitmap_ColorPattern
 ,
 kRect_DrawType
 )
 ;
 )
