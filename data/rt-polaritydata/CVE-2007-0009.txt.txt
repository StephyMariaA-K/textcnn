 diff
 -
 u
 -
9
 -
r1.34
 sslcon.c
 -
 -
 -
 a
 /
 security
 /
 nss
 /
 lib
 /
 ssl
 /
sslcon.c	14
 Nov
2006
01
:09
:54
 -
0000
	1
.34
 +
 +
 +
 b
 /
 security
 /
 nss
 /
 lib
 /
 ssl
 /
sslcon.c	19
 Dec
2006
22
:10
:40
 -
0000
 -
1573
 ,
46
 +
1573
 ,
36
 *
 *
 *
 *
 Called
 from
 ssl2_HandleClientSessionKeyMessage
 (
 )
 *
 /
 static
 SECStatus
 ssl2_ServerSetupSessionCypher
 (
 sslSocket
 *
 ss
 ,
 int
 cipher
 ,
 unsigned
 int
 keyBits
 ,
 PRUint8
 *
 ck
 ,
 unsigned
 int
 ckLen
 ,
 PRUint8
 *
 ek
 ,
 unsigned
 int
 ekLen
 ,
 PRUint8
 *
 ca
 ,
 unsigned
 int
 caLen
 )
 {
 -
 PRUint8
 *
 kk
=
 NULL
 ;
 +
 PRUint8
 *
 dk
=
 NULL
 ;
 sslSessionID
 *
 sid
 ;
 +
 sslServerCerts
 *
 sc
=
 ss
 -
 >
 erverCerts
 +
 kt_rsa
 ;
 PRUint8
 *
 kbuf
=
0
 ;
 -
 unsigned
 int
 el1
 ;
 +
 unsigned
 int
 ddLen
 ;
 unsigned
 int
 keySize
 ;
 -
 unsigned
 int
 modulusLen
 ;
 +
 unsigned
 int
 dkLen
 ;
 +
 int
 modulusLen
 ;
 SECStatus
 rv
 ;
 +
PRUint16
 allowed
 ;
 PRUint8
 mkbuf[SSL_MAX_MASTER_KEY_BYTES]
 ;
 -
 sslServerCerts
 *
 sc
=
 ss
 -
 >
 erverCerts
 +
 kt_rsa
 ;
 PORT_Assert
 (
 ss
 -
 >
 pt.noLocks
 |
 |
 ssl_Have1stHandshakeLock
 (
 ss
 )
 )
 ;
 PORT_Assert
 (
 ss
 -
 >
 pt.noLocks
 |
 |
 ssl_HaveRecvBufLock
 (
 ss
 )
 )
 ;
 PORT_Assert
 (
 (
 sc
 -
 >
 ERVERKEY
 !
=
0
 )
 )
 ;
 PORT_Assert
 (
 (
 ss
 -
 >
 ec.ci.sid
 !
=
0
 )
 )
 ;
 sid
=
 ss
 -
 >
 ec.ci.sid
 ;
 -
 keySize
=
 (
 keyBits
 +
7
 )
3
 ;
 -
 -
 if
 (
 keySize
 >
 SSL_MAX_MASTER_KEY_BYTES
 )
 {
 -
 -
 (
 (
"%d: SSL[%d]: keySize=%d ckLen=%d max session key size=%d"
 ,
 -
 SSL_GETPID
 (
 )
 ,
 ss
 -
 >
 d
 ,
 keySize
 ,
 ckLen
 ,
 -
 SSL_MAX_MASTER_KEY_BYTES
 )
 )
 ;
 -
 (
 SSL_ERROR_BAD_CLIENT
 )
 ;
 -
 loser
 ;
 -
 }
 -
 -
 switch
 (
 cipher
 )
 {
 case
SSL_CK_RC4_128
_EXPORT40
 case
SSL_CK_RC4_128
 case
SSL_CK_RC2_128
_CBC_EXPORT40
 case
SSL_CK_RC2_128
 case
SSL_CK_DES_64
 -
1620
 ,
98
 +
1610
 ,
116
 ;
 default:
 (
 (
"%d: SSL[%d]: ssl2_ServerSetupSessionCypher: unknown cipher=%d"
 ,
 SSL_GETPID
 (
 )
 ,
 ss
 -
 >
 d
 ,
 cipher
 )
 )
 ;
 (
 SSL_ERROR_BAD_CLIENT
 )
 ;
 loser
 ;
 }
 -
 +
 allowed
=
 ss
 -
 >
 llowedByPolicy
 &
 ss
 -
 >
 hosenPreference
 &
 SSL_CB_IMPLEMENTED
 ;
 +
 if
 (
 !
 (
 allowed
 &
 (
1
 cipher
 )
 )
 )
 {
 +
 +
 (
 (
"%d: SSL[%d]: disallowed cipher=%d"
 ,
 +
 SSL_GETPID
 (
 )
 ,
 ss
 -
 >
 d
 ,
 cipher
 )
 )
 ;
 +
 (
 SSL_ERROR_BAD_CLIENT
 )
 ;
 +
 loser
 ;
 +
 }
 +
 +
 keySize
=
 ssl_Specs[cipher].keyLen
 ;
 +
 if
 (
 keyBits
 !
=
 keySize
 *
 BPB
 )
 {
 +
 (
 (
"%d: SSL[%d]: invalid master secret key length=%d (bits)!"
 ,
 +
 SSL_GETPID
 (
 )
 ,
 ss
 -
 >
 d
 ,
 keyBits
 )
 )
 ;
 +
 (
 SSL_ERROR_BAD_CLIENT
 )
 ;
 +
 loser
 ;
 +
 }
 +
 if
 (
 ckLen
 !
=
 ssl_Specs[cipher].pubLen
 )
 {
 -
 (
 (
"%d: SSL[%d]: odd secret key size, keySize=%d ckLen=%d!"
 ,
 -
 SSL_GETPID
 (
 )
 ,
 ss
 -
 >
 d
 ,
 keySize
 ,
 ckLen
 )
 )
 ;
 -
 +
 (
 (
"%d: SSL[%d]: invalid clear key length, ckLen=%d (bytes)!"
 ,
 +
 SSL_GETPID
 (
 )
 ,
 ss
 -
 >
 d
 ,
 ckLen
 )
 )
 ;
 +
 (
 SSL_ERROR_BAD_CLIENT
 )
 ;
 +
 loser
 ;
 +
 }
 +
 +
 if
 (
 caLen
 !
=
 ssl_Specs[cipher].ivLen
 )
 {
 +
 (
 (
"%d: SSL[%d]: invalid key args length, caLen=%d (bytes)!"
 ,
 +
 SSL_GETPID
 (
 )
 ,
 ss
 -
 >
 d
 ,
 caLen
 )
 )
 ;
 +
 (
 SSL_ERROR_BAD_CLIENT
 )
 ;
 +
 loser
 ;
 +
 }
 +
 +
 modulusLen
=
PK11
 (
 sc
 -
 >
 ERVERKEY
 )
 ;
 +
 if
 (
 modulusLen
 ==
 -
1
 )
 {
 +
 +
=
 ekLen
 ;
 +
 }
 +
 if
 (
 ekLen
 >
 modulusLen
 |
 |
 ekLen
 +
 ckLen
 <
 keySize
 )
 {
 +
 (
 (
"%d: SSL[%d]: invalid encrypted key length, ekLen=%d (bytes)!"
 ,
 +
 SSL_GETPID
 (
 )
 ,
 ss
 -
 >
 d
 ,
 ekLen
 )
 )
 ;
 (
 SSL_ERROR_BAD_CLIENT
 )
 ;
 loser
 ;
 }
 -
 -
 kbuf
=
 (
 PRUint8
 *
 )
 PORT_Alloc
 (
 ekLen
 )
 ;
 +
 kbuf
=
 (
 PRUint8
 *
 )
 PORT_Alloc
 (
 modulusLen
 )
 ;
 if
 (
 !
 kbuf
 )
 {
 loser
 ;
 }
 +
 dkLen
=
 keySize
 -
 ckLen
 ;
 +
 dk
=
 kbuf
 +
 modulusLen
 -
 dkLen
 ;
 -
 -
 rv
=
PK11
 (
 sc
 -
 >
 ERVERKEY
 ,
 kbuf
 ,
 &
 el1
 ,
 ekLen
 ,
 ek
 ,
 ekLen
 )
 ;
 +
 rv
=
PK11
 (
 sc
 -
 >
 ERVERKEY
 ,
 kbuf
 ,
 &
 ddLen
 ,
 modulusLen
 ,
 ek
 ,
 ekLen
 )
 ;
 if
 (
 rv
 !
=
 SECSuccess
 )
 hide_loser
 ;
 -
 modulusLen
=
PK11
 (
 sc
 -
 >
 ERVERKEY
 )
 ;
 -
 if
 (
 modulusLen
 ==
 -
1
 )
 {
 -
 -
=
 ekLen
 ;
 -
 }
 -
 -
 if
 (
 modulusLen
 !
=
 el1
 )
 +
 +
 if
 (
 modulusLen
 !
=
 ddLen
 )
 hide_loser
 ;
 -
 kk
=
 kbuf
 +
 modulusLen
 -
 (
 keySize
 -
 ckLen
 )
 ;
 -
 if
 (
 (
kbuf[0
 !
=
0
x00
 )
 |
 |
 (
kbuf[1
 !
=
0
x02
 )
 |
 |
 (
 kk[
 -
1
 !
=
0
x00
 )
 )
 {
 -
 +
 if
 (
 (
kbuf[0
 !
=
0
x00
 )
 |
 |
 (
kbuf[1
 !
=
0
x02
 )
 |
 |
 (
 dk[
 -
1
 !
=
0
x00
 )
 )
 {
 (
 (
"%d: SSL[%d]: strange encryption block"
 ,
 SSL_GETPID
 (
 )
 ,
 ss
 -
 >
 d
 )
 )
 ;
 (
 SSL_ERROR_BAD_CLIENT
 )
 ;
 hide_loser
 ;
 }
 if
 (
 ss
 -
 >
 pt.enableSSL3
 |
 |
 ss
 -
 >
 pt.enableTLS
 )
 {
 -
threes[8
=
 {
0
x03
 ,
0
x03
 ,
0
x03
 ,
0
x03
 ,
 -
0
x03
 ,
0
x03
 ,
0
x03
 ,
0
x03
 }
 ;
 +
 const
 PRUint8
threes[8
=
 {
0
x03
 ,
0
x03
 ,
0
x03
 ,
0
x03
 ,
 +
0
x03
 ,
0
x03
 ,
0
x03
 ,
0
x03
 }
 ;
 -
 (
 PORT_Memcmp
 (
 kk
 -
8
 -
1
 ,
 threes
 ,
8
 )
 ==
0
 )
 {
 +
 (
 PORT_Memcmp
 (
 dk
 -
8
 -
1
 ,
 threes
 ,
8
 )
 ==
0
 )
 {
 PORT_SetError
 (
 SSL_ERROR_BAD_CLIENT
 )
 ;
 goto
 hide_loser
 ;
 }
 }
 if
 (
0
 )
 {
 hide_loser:
 -
	PK11
 (
 kbuf
 ,
 ekLen
 )
 ;
 -
 (
 !
 kk
 )
 {
 -
 kk
=
 kbuf
 +
 ekLen
 -
 (
 keySize
 -
 ckLen
 )
 ;
 -
 }
 +
	PK11
 (
 dk
 ,
 dkLen
 )
 ;
 }
 if
 (
 ckLen
 )
 {
 (
 mkbuf
 ,
 ck
 ,
 ckLen
 )
 ;
 }
 -
 PORT_Memcpy
 (
 mkbuf
 +
 ckLen
 ,
 kk
 ,
 keySize
 -
 ckLen
 )
 ;
 +
 PORT_Memcpy
 (
 mkbuf
 +
 ckLen
 ,
 dk
 ,
 dkLen
 )
 ;
 rv
=
 ssl2_FillInSID
 (
 sid
 ,
 cipher
 ,
 mkbuf
 ,
 keySize
 ,
 ca
 ,
 caLen
 ,
 keyBits
 ,
 keyBits
 -
 (
 ckLen<<
 )
 ,
 ss
 -
 >
 ec.authAlgorithm
 ,
 ss
 -
 >
 ec.authKeyBits
 ,
 ss
 -
 >
 ec.keaType
 ,
 ss
 -
 >
 ec.keaKeyBits
 )
 ;
 if
 (
 rv
 !
=
 SECSuccess
 )
 {
 loser
 ;
 }
 -
1975
 ,
19
 +
1983
 ,
22
 unsigned
 char
 *
 ssl_FormatSSL2Block
 (
 unsigned
 modulusLen
 ,
 SECItem
 *
 data
 )
 {
 unsigned
 char
 *
 block
 ;
 unsigned
 char
 *
 bp
 ;
 int
 padLen
 ;
 SECStatus
 rv
 ;
 int
 i
 ;
 -
 PORT_Assert
 (
 data
 -
 >
 en
 <=
 (
 modulusLen
 -
 (
3
 +
 RSA_BLOCK_MIN_PAD_LEN
 )
 )
 )
 ;
 +
 if
 (
 modulusLen
 <
 data
 -
 >
 en
 +
 (
3
 +
 RSA_BLOCK_MIN_PAD_LEN
 )
 )
 {
 +
 (
 SEC_ERROR_BAD_KEY
 )
 ;
 +
 NULL
 ;
 +
 }
 block
=
 (
 unsigned
 char
 *
 )
 PORT_Alloc
 (
 modulusLen
 )
 ;
 if
 (
 block
 ==
 NULL
 )
 NULL
 ;
 bp
=
 block
 ;
 static
 SECStatus
 ssl2_HandleClientSessionKeyMessage
 (
 sslSocket
 *
 ss
 )
 {
 PRUint8
 *
 data
 ;
 unsigned
 int
 caLen
 ;
 unsigned
 int
 ckLen
 ;
 unsigned
 int
 ekLen
 ;
 -
 unsigned
 int
 keySize
 ;
 +
 unsigned
 int
 keyBits
 ;
 int
 cipher
 ;
 SECStatus
 rv
 ;
 ssl_GetRecvBufLock
 (
 ss
 )
 ;
 data
=
 ss
 -
 >
 s.buf.buf
 +
 ss
 -
 >
 s.recordOffset
 ;
 DUMP_MSG
 (
29
 ,
 (
 ss
 ,
 data
 ,
 ss
 -
 >
 s.recordLen
 )
 )
 ;
 if
 (
 (
 ss
 -
 >
 s.recordLen
 <
 SSL_HL_CLIENT_MASTER_KEY_HBYTES
 )
 |
 |
 (
data[0
 !
=
 SSL_MT_CLIENT_MASTER_KEY
 )
 )
 {
 bad_client
 ;
 }
 cipher
=
data[1
 ;
 -
 keySize
=
 (
data[2
8
 )
 |
data[3
 ;
 +
 keyBits
=
 (
data[2
8
 )
 |
data[3
 ;
 ckLen
=
 (
data[4
8
 )
 |
data[5
 ;
 ekLen
=
 (
data[6
8
 )
 |
data[7
 ;
 caLen
=
 (
data[8
8
 )
 |
data[9
 ;
 -
 SSL_TRC
 (
5
 ,
 (
"%d: SSL[%d]: session-key, cipher=%d keySize=%d ckLen=%d ekLen=%d caLen=%d"
 ,
 -
 (
 )
 ,
 ss
 -
 >
 d
 ,
 cipher
 ,
 keySize
 ,
 ckLen
 ,
 ekLen
 ,
 caLen
 )
 )
 ;
 +
 SSL_TRC
 (
5
 ,
 (
"%d: SSL[%d]: session-key, cipher=%d keyBits=%d ckLen=%d ekLen=%d caLen=%d"
 ,
 +
 (
 )
 ,
 ss
 -
 >
 d
 ,
 cipher
 ,
 keyBits
 ,
 ckLen
 ,
 ekLen
 ,
 caLen
 )
 )
 ;
 if
 (
 ss
 -
 >
 s.recordLen
 <
 SSL_HL_CLIENT_MASTER_KEY_HBYTES
 +
 ckLen
 +
 ekLen
 +
 caLen
 )
 {
 (
 (
"%d: SSL[%d]: protocol size mismatch dataLen=%d"
 ,
 SSL_GETPID
 (
 )
 ,
 ss
 -
 >
 d
 ,
 ss
 -
 >
 s.recordLen
 )
 )
 ;
 bad_client
 ;
 }
 -
 -
 rv
=
 ssl2_ServerSetupSessionCypher
 (
 ss
 ,
 cipher
 ,
 keySize
 ,
 +
 rv
=
 ssl2_ServerSetupSessionCypher
 (
 ss
 ,
 cipher
 ,
 keyBits
 ,
 +
 SSL_HL_CLIENT_MASTER_KEY_HBYTES
 ,
 ckLen
 ,
 +
 SSL_HL_CLIENT_MASTER_KEY_HBYTES
 +
 ckLen
 ,
 ekLen
 ,
 +
 SSL_HL_CLIENT_MASTER_KEY_HBYTES
 +
 ckLen
 +
 ekLen
 ,
 caLen
 )
 ;
 ss
 -
 >
 s.recordLen
=
0
 ;
 ssl_ReleaseRecvBufLock
 (
 ss
 )
 ;
 if
 (
 rv
 !
=
 SECSuccess
 )
 {
 loser
 ;
 -
3276
 ,
19
 +
3286
 ,
20
 rv
=
 ssl2_TryToFinish
 (
 ss
 )
 ;
 if
 (
 rv
 !
=
 SECSuccess
 )
 loser
 ;
 if
 (
 ss
 -
 >
 andshake
 ==
0
 )
 {
 SECSuccess
 ;
 }
 SSL_TRC
 (
5
 ,
 (
"%d: SSL[%d]: server: waiting for elements=0x%d"
 ,
 -
 (
 )
 ,
 ss
 -
 >
 d
 ,
 ss
 -
 >
 ec.ci.requiredElements
 ss
 -
 >
 ec.ci.elements
 )
 )
 ;
 +
 (
 )
 ,
 ss
 -
 >
 d
 ,
 +
 -
 >
 ec.ci.requiredElements
 ss
 -
 >
 ec.ci.elements
 )
 )
 ;
 ss
 -
 >
 andshake
=
 ssl_GatherRecord1stHandshake
 ;
 ss
 -
 >
 extHandshake
=
 ssl2_HandleMessage
 ;
 return
 ssl2_TriggerNextMessage
 (
 ss
 )
 ;
 bad_client:
 ssl_ReleaseRecvBufLock
 (
 ss
 )
 ;
 PORT_SetError
 (
 SSL_ERROR_BAD_CLIENT
 )
 ;
