 class
 AAClipBench
 public
 Benchmark
 {
 SkString
 fName
 ;
 SkPath
 fClipPath
 ;
 SkRect
 fClipRect
 ;
 SkRect
 fDrawRect
 ;
 bool
 fDoPath
 ;
 bool
 fDoAA
 ;
 public:
 AAClipBench
 (
 bool
 doPath
 ,
 bool
 doAA
 )
 fDoPath
 (
 doPath
 )
 ,
 fDoAA
 (
 doAA
 )
 {
 fName.printf
 (
"aaclip_%s_%s"
 ,
 doPath
"path"
"rect"
 ,
 doAA
"AA"
"BW"
 )
 ;
 fClipRect.set
 (
10
.5
 f
 ,
10
.5
 f
 ,
50
.5
 f
 ,
50
.5
 f
 )
 ;
 fClipPath.addRoundRect
 (
 fClipRect
 ,
 SkIntToScalar
 (
10
 )
 ,
 SkIntToScalar
 (
10
 )
 )
 ;
 fDrawRect.set
 (
 SkIntToScalar
 (
0
 )
 ,
 SkIntToScalar
 (
0
 )
 ,
 SkIntToScalar
 (
100
 )
 ,
 SkIntToScalar
 (
100
 )
 )
 ;
 SkASSERT
 (
 fClipPath.isConvex
 (
 )
 )
 ;
 }
 protected:
 virtual
 const
 char
 *
 onGetName
 (
 )
 {
 return
 fName.c_str
 (
 )
 ;
 }
 virtual
 void
 onDraw
 (
 int
 loops
 ,
 SkCanvas
 *
 canvas
 )
 {
 SkPaint
 paint
 ;
 this
 -
 >
 etupPaint
 (
 &
 paint
 )
 ;
 for
 (
 int
 i
=
0
 ;
 i
 <
 loops
 ;
 +
 +
 i
 )
 {
 fClipRect.offset
 (
 (
 i
2
 )
 ==
0
 SkIntToScalar
 (
10
 )
 SkIntToScalar
 (
 -
10
 )
 ,
0
 )
 ;
 fClipPath.reset
 (
 )
 ;
 fClipPath.addRoundRect
 (
 fClipRect
 ,
 SkIntToScalar
 (
5
 )
 ,
 SkIntToScalar
 (
5
 )
 )
 ;
 SkASSERT
 (
 fClipPath.isConvex
 (
 )
 )
 ;
 canvas
 -
 >
 ave
 (
 )
 ;
 if
 (
 fDoPath
 )
 {
 canvas
 -
 >
 lipPath
 (
 fClipPath
 ,
 kReplace_SkClipOp
 ,
 fDoAA
 )
 ;
 }
 else
 {
 canvas
 -
 >
 lipRect
 (
 fClipRect
 ,
 kReplace_SkClipOp
 ,
 fDoAA
 )
 ;
 }
 canvas
 -
 >
 rawRect
 (
 fDrawRect
 ,
 paint
 )
 ;
 if
 (
 fDoPath
 )
 {
 canvas
 -
 >
 rawPath
 (
 fClipPath
 ,
 paint
 )
 ;
 }
 else
 {
 canvas
 -
 >
 rawRect
 (
 fClipRect
 ,
 paint
 )
 ;
 }
 canvas
 -
 >
 estore
 (
 )
 ;
 }
 }
 private:
 typedef
 Benchmark
 INHERITED
 ;
 }
 ;
 class
 NestedAAClipBench
 public
 Benchmark
 {
 SkString
 fName
 ;
 bool
 fDoAA
 ;
 SkRect
 fDrawRect
 ;
 SkRandom
 fRandom
 ;
 static
 const
 int
 kNestingDepth
=
3
 ;
 static
 const
 int
 kImageSize
=
400
 ;
 SkPoint
 fSizes[kNestingDepth
 +
1
 ;
 public:
 NestedAAClipBench
 (
 bool
 doAA
 )
 fDoAA
 (
 doAA
 )
 {
 fName.printf
 (
"nested_aaclip_%s"
 ,
 doAA
"AA"
"BW"
 )
 ;
 fDrawRect
=
 SkRect::MakeLTRB
 (
0
 ,
0
 ,
 SkIntToScalar
 (
 kImageSize
 )
 ,
 SkIntToScalar
 (
 kImageSize
 )
 )
 ;
fSizes[0
 (
 SkIntToScalar
 (
 kImageSize
 )
 ,
 SkIntToScalar
 (
 kImageSize
 )
 )
 ;
 for
 (
 int
 i
=
1
 ;
 i
 <
 kNestingDepth
 +
1
 ;
 +
 +
 i
 )
 {
 fSizes[i].set
 (
 fSizes[i
 -
1
 /
2
 ,
 fSizes[i
 -
1
 /
2
 )
 ;
 }
 }
 protected:
 virtual
 const
 char
 *
 onGetName
 (
 )
 {
 return
 fName.c_str
 (
 )
 ;
 }
 void
 recurse
 (
 SkCanvas
 *
 canvas
 ,
 int
 depth
 ,
 const
 SkPoint
 &
 offset
 )
 {
 canvas
 -
 >
 ave
 (
 )
 ;
 SkRect
 temp
=
 SkRect::MakeLTRB
 (
0
 ,
0
 ,
 fSizes[depth].fX
 ,
 fSizes[depth].fY
 )
 ;
 temp.offset
 (
 offset
 )
 ;
 SkPath
 path
 ;
 path.addRoundRect
 (
 temp
 ,
 SkIntToScalar
 (
3
 )
 ,
 SkIntToScalar
 (
3
 )
 )
 ;
 SkASSERT
 (
 path.isConvex
 (
 )
 )
 ;
 canvas
 -
 >
 lipPath
 (
 path
 ,
0
 ==
 depth
 kReplace_SkClipOp
 kIntersect_SkClipOp
 ,
 fDoAA
 )
 ;
 if
 (
 kNestingDepth
 ==
 depth
 )
 {
 SkPaint
 paint
 ;
 paint.setColor
 (
0
xff000000
 |
 fRandom.nextU
 (
 )
 )
 ;
 canvas
 -
 >
 rawRect
 (
 fDrawRect
 ,
 paint
 )
 ;
 }
 else
 {
 SkPoint
 childOffset
=
 offset
 ;
 this
 -
 >
 ecurse
 (
 canvas
 ,
 depth
 +
1
 ,
 childOffset
 )
 ;
 childOffset
 +
=
 fSizes[depth
 +
1
 ;
 this
 -
 >
 ecurse
 (
 canvas
 ,
 depth
 +
1
 ,
 childOffset
 )
 ;
 childOffset.fX
=
 offset.fX
 +
 fSizes[depth
 +
1
 ;
 childOffset.fY
=
 offset.fY
 ;
 this
 -
 >
 ecurse
 (
 canvas
 ,
 depth
 +
1
 ,
 childOffset
 )
 ;
 childOffset.fX
=
 offset.fX
 ;
 childOffset.fY
=
 offset.fY
 +
 fSizes[depth
 +
1
 ;
 this
 -
 >
 ecurse
 (
 canvas
 ,
 depth
 +
1
 ,
 childOffset
 )
 ;
 }
 canvas
 -
 >
 estore
 (
 )
 ;
 }
 virtual
 void
 onDraw
 (
 int
 loops
 ,
 SkCanvas
 *
 canvas
 )
 {
 for
 (
 int
 i
=
0
 ;
 i
 <
 loops
 ;
 +
 +
 i
 )
 {
 SkPoint
 offset
=
 SkPoint::Make
 (
0
 ,
0
 )
 ;
 this
 -
 >
 ecurse
 (
 canvas
 ,
0
 ,
 offset
 )
 ;
 }
 }
 private:
 typedef
 Benchmark
 INHERITED
 ;
 }
 ;
 class
 AAClipBuilderBench
 public
 Benchmark
 {
 SkString
 fName
 ;
 SkPath
 fPath
 ;
 SkRect
 fRect
 ;
 SkRegion
 fRegion
 ;
 bool
 fDoPath
 ;
 bool
 fDoAA
 ;
 public:
 AAClipBuilderBench
 (
 bool
 doPath
 ,
 bool
 doAA
 )
 {
 fDoPath
=
 doPath
 ;
 fDoAA
=
 doAA
 ;
 fName.printf
 (
"aaclip_build_%s_%s"
 ,
 doPath
"path"
"rect"
 ,
 doAA
"AA"
"BW"
 )
 ;
 fRegion.setRect
 (
0
 ,
0
 ,
640
 ,
480
 )
 ;
 fRect.set
 (
 fRegion.getBounds
 (
 )
 )
 ;
 fRect.inset
 (
 SK_Scalar1
 /
4
 ,
 SK_Scalar1
 /
4
 )
 ;
 fPath.addRoundRect
 (
 fRect
 ,
 SkIntToScalar
 (
20
 )
 ,
 SkIntToScalar
 (
20
 )
 )
 ;
 }
 protected:
 virtual
 const
 char
 *
 onGetName
 (
 )
 {
 return
 fName.c_str
 (
 )
 ;
 }
 virtual
 void
 onDraw
 (
 int
 loops
 ,
 SkCanvas
 *
 )
 {
 SkPaint
 paint
 ;
 this
 -
 >
 etupPaint
 (
 &
 paint
 )
 ;
 for
 (
 int
 i
=
0
 ;
 i
 <
 loops
 ;
 +
 +
 i
 )
 {
 SkAAClip
 clip
 ;
 if
 (
 fDoPath
 )
 {
 clip.setPath
 (
 fPath
 ,
 &
 fRegion
 ,
 fDoAA
 )
 ;
 }
 else
 {
 clip.setRect
 (
 fRect
 ,
 fDoAA
 )
 ;
 }
 }
 }
 private:
 typedef
 Benchmark
 INHERITED
 ;
 }
 ;
 class
 AAClipRegionBench
 public
 Benchmark
 {
 public:
 AAClipRegionBench
 (
 )
 {
 SkPath
 path
 ;
 path.addCircle
 (
0
 ,
0
 ,
 SkIntToScalar
 (
200
 )
 )
 ;
 path.addCircle
 (
0
 ,
0
 ,
 SkIntToScalar
 (
180
 )
 )
 ;
 path.setFillType
 (
 SkPath::kEvenOdd_FillType
 )
 ;
 SkIRect
 bounds
 ;
 path.getBounds
 (
 )
 (
 &
 bounds
 )
 ;
 fRegion.setPath
 (
 path
 ,
 SkRegion
 (
 bounds
 )
 )
 ;
 }
 protected:
 virtual
 const
 char
 *
 onGetName
 (
 )
 {
 return
"aaclip_setregion"
 ;
 }
 virtual
 void
 onDraw
 (
 int
 loops
 ,
 SkCanvas
 *
 )
 {
 for
 (
 int
 i
=
0
 ;
 i
 <
 loops
 ;
 +
 +
 i
 )
 {
 SkAAClip
 clip
 ;
 clip.setRegion
 (
 fRegion
 )
 ;
 }
 }
 private:
 SkRegion
 fRegion
 ;
 typedef
 Benchmark
 INHERITED
 ;
 }
 ;
 DEF_BENCH
 (
 return
 new
 AAClipBuilderBench
 (
 false
 ,
 false
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AAClipBuilderBench
 (
 false
 ,
 true
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AAClipBuilderBench
 (
 true
 ,
 false
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AAClipBuilderBench
 (
 true
 ,
 true
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AAClipRegionBench
 (
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AAClipBench
 (
 false
 ,
 false
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AAClipBench
 (
 false
 ,
 true
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AAClipBench
 (
 true
 ,
 false
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AAClipBench
 (
 true
 ,
 true
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 NestedAAClipBench
 (
 false
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 NestedAAClipBench
 (
 true
 )
 ;
 )
 enum
 ColorPattern
 {
 kWhite_ColorPattern
 ,
 kBlue_ColorPattern
 ,
 kOpaqueBitmap_ColorPattern
 ,
 kAlphaBitmap_ColorPattern
 ,
 }
 ;
 static
 const
 struct
 ColorPatternData
 {
 SkColor
 fColor
 ;
 bool
 fIsBitmap
 ;
 const
 char
 *
 fName
 ;
 }
 gColorPatterns[]
=
 {
 {
 SK_ColorWHITE
 ,
 false
 ,
"white"
 }
 ,
 {
 SK_ColorBLUE
 ,
 false
 ,
"blue"
 }
 ,
 {
 SK_ColorWHITE
 ,
 true
 ,
"obaqueBitMap"
 }
 ,
 {
0
x10000000
 ,
 true
 ,
"alphaBitmap"
 }
 ,
 }
 ;
 enum
 DrawType
 {
 kRect_DrawType
 ,
 kPath_DrawType
 ,
 }
 ;
 static
 void
 makebm
 (
 SkBitmap
 *
 bm
 ,
 int
 w
 ,
 int
 h
 )
 {
 bm
 -
 >
llocN32
 Pixels
 (
 w
 ,
 h
 )
 ;
 bm
 -
 >
 raseColor
 (
 SK_ColorTRANSPARENT
 )
 ;
 SkCanvas
 canvas
 (
 *
 bm
 )
 ;
 SkScalar
 s
=
 SkIntToScalar
 (
SkMin32
 (
 w
 ,
 h
 )
 )
 ;
 static
 const
 SkPoint
 kPts0[]
=
 {
 {
0
 ,
0
 }
 ,
 {
 s
 ,
 s
 }
 }
 ;
 static
 const
 SkPoint
 kPts1[]
=
 {
 {
 s
 /
2
 ,
0
 }
 ,
 {
 s
 /
2
 ,
 s
 }
 }
 ;
 static
 const
 SkScalar
 kPos[]
=
 {
0
 ,
 SK_Scalar1
 /
2
 ,
 SK_Scalar1
 }
 ;
 static
 const
 SkColor
 kColors0[]
=
 {
0
x80
F00080
 ,
0
xF0F08000
 ,
0
x800080
 F0
 }
 ;
 static
 const
 SkColor
 kColors1[]
=
 {
0
xF08000
 F0
 ,
0
x8080
F000
 ,
0
xF000
F080
 }
 ;
 SkPaint
 paint
 ;
 paint.setShader
 (
 SkGradientShader::MakeLinear
 (
 kPts0
 ,
 kColors0
 ,
 kPos
 ,
 SK_ARRAY_COUNT
 (
 kColors0
 )
 ,
 SkShader::kClamp_TileMode
 )
 )
 ;
 canvas.drawPaint
 (
 paint
 )
 ;
 paint.setShader
 (
 SkGradientShader::MakeLinear
 (
 kPts1
 ,
 kColors1
 ,
 kPos
 ,
 SK_ARRAY_COUNT
 (
 kColors1
 )
 ,
 SkShader::kClamp_TileMode
 )
 )
 ;
 canvas.drawPaint
 (
 paint
 )
 ;
 }
 class
 AlternatingColorPatternBench
 public
 Benchmark
 {
 public:
 enum
 {
 NX
=
5
 ,
 NY
=
5
 ,
 NUM_DRAWS
=
 NX
 *
 NY
 ,
 }
 ;
 sk_sp<
 kShader>
 fBmShader
 ;
 SkPath
 fPaths[NUM_DRAWS]
 ;
 SkRect
 fRects[NUM_DRAWS]
 ;
 SkColor
 fColors[NUM_DRAWS]
 ;
 sk_sp<
 kShader>
 fShaders[NUM_DRAWS]
 ;
 SkString
 fName
 ;
 ColorPatternData
 fPattern1
 ;
 ColorPatternData
 fPattern2
 ;
 DrawType
 fDrawType
 ;
 SkBitmap
 fBmp
 ;
 AlternatingColorPatternBench
 (
 ColorPattern
 pattern1
 ,
 ColorPattern
 pattern2
 ,
 DrawType
 drawType
 )
 {
 fPattern1
=
 gColorPatterns[pattern1]
 ;
 fPattern2
=
 gColorPatterns[pattern2]
 ;
 fName.printf
 (
"colorPattern_%s_%s_%s"
 ,
 fPattern1.fName
 ,
 fPattern2.fName
 ,
 kRect_DrawType
 ==
 drawType
"rect"
"path"
 )
 ;
 fDrawType
=
 drawType
 ;
 }
 protected:
 const
 char
 *
 onGetName
 (
 )
 override
 {
 return
 fName.c_str
 (
 )
 ;
 }
 void
 onDelayedSetup
 (
 )
 override
 {
 int
 w
=
40
 ;
 int
 h
=
40
 ;
 makebm
 (
 &
 fBmp
 ,
 w
 ,
 h
 )
 ;
 fBmShader
=
 SkShader::MakeBitmapShader
 (
 fBmp
 ,
 SkShader::kRepeat_TileMode
 ,
 SkShader::kRepeat_TileMode
 )
 ;
 int
 offset
=
2
 ;
 int
 count
=
0
 ;
 for
 (
 int
 j
=
0
 ;
 j
 <
 NY
 ;
 +
 +
 j
 )
 {
 for
 (
 int
 i
=
0
 ;
 i
 <
 NX
 ;
 +
 +
 i
 )
 {
 int
 x
=
 (
 w
 +
 offset
 )
 *
 i
 ;
 int
 y
=
 (
 h
 *
 offset
 )
 *
 j
 ;
 if
 (
 kRect_DrawType
 ==
 fDrawType
 )
 {
 fRects[count].set
 (
 SkIntToScalar
 (
 x
 )
 ,
 SkIntToScalar
 (
 y
 )
 ,
 SkIntToScalar
 (
 x
 +
 w
 )
 ,
 SkIntToScalar
 (
 y
 +
 h
 )
 )
 ;
 }
 else
 {
 fPaths[count].moveTo
 (
 SkIntToScalar
 (
 x
 )
 ,
 SkIntToScalar
 (
 y
 )
 )
 ;
 fPaths[count].rLineTo
 (
 SkIntToScalar
 (
 w
 )
 ,
0
 )
 ;
 fPaths[count].rLineTo
 (
0
 ,
 SkIntToScalar
 (
 h
 )
 )
 ;
 fPaths[count].rLineTo
 (
 SkIntToScalar
 (
 -
 w
 +
1
 )
 ,
0
 )
 ;
 }
 if
 (
0
 ==
 count
2
 )
 {
 fColors[count]
=
 fPattern1.fColor
 ;
 fShaders[count]
=
 fPattern1.fIsBitmap
 fBmShader
 nullptr
 ;
 }
 else
 {
 fColors[count]
=
 fPattern2.fColor
 ;
 fShaders[count]
=
 fPattern2.fIsBitmap
 fBmShader
 nullptr
 ;
 }
 +
 +
 count
 ;
 }
 }
 }
 void
 onDraw
 (
 int
 loops
 ,
 SkCanvas
 *
 canvas
 )
 override
 {
 SkPaint
 paint
 ;
 paint.setAntiAlias
 (
 false
 )
 ;
 paint.setFilterQuality
 (
 kLow_SkFilterQuality
 )
 ;
 for
 (
 int
 i
=
0
 ;
 i
 <
 loops
 ;
 +
 +
 i
 )
 {
 for
 (
 int
 j
=
0
 ;
 j
 <
 NUM_DRAWS
 ;
 +
 +
 j
 )
 {
 paint.setColor
 (
 fColors[j]
 )
 ;
 paint.setShader
 (
 fShaders[j]
 )
 ;
 if
 (
 kRect_DrawType
 ==
 fDrawType
 )
 {
 canvas
 -
 >
 rawRect
 (
 fRects[j]
 ,
 paint
 )
 ;
 }
 else
 {
 canvas
 -
 >
 rawPath
 (
 fPaths[j]
 ,
 paint
 )
 ;
 }
 }
 }
 }
 private:
 typedef
 Benchmark
 INHERITED
 ;
 }
 ;
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kWhite_ColorPattern
 ,
 kWhite_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kBlue_ColorPattern
 ,
 kBlue_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kWhite_ColorPattern
 ,
 kBlue_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kOpaqueBitmap_ColorPattern
 ,
 kOpaqueBitmap_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kAlphaBitmap_ColorPattern
 ,
 kAlphaBitmap_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kOpaqueBitmap_ColorPattern
 ,
 kAlphaBitmap_ColorPattern
 ,
 kPath_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kOpaqueBitmap_ColorPattern
 ,
 kOpaqueBitmap_ColorPattern
 ,
 kRect_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kAlphaBitmap_ColorPattern
 ,
 kAlphaBitmap_ColorPattern
 ,
 kRect_DrawType
 )
 ;
 )
 DEF_BENCH
 (
 return
 new
 AlternatingColorPatternBench
 (
 kOpaqueBitmap_ColorPattern
 ,
 kAlphaBitmap_ColorPattern
 ,
 kRect_DrawType
 )
 ;
 )
 AndroidCodecBench::AndroidCodecBench
 (
 SkString
 baseName
 ,
 SkData
 *
 encoded
 ,
 int
 sampleSize
 )
 fData
 (
 SkRef
 (
 encoded
 )
 )
 ,
 fSampleSize
 (
 sampleSize
 )
 {
 fName.printf
 (
"AndroidCodec_%s_SampleSize%d"
 ,
 baseName.c_str
 (
 )
 ,
 sampleSize
 )
 ;
 }
 const
 char
 *
 AndroidCodecBench::onGetName
 (
 )
 {
 return
 fName.c_str
 (
 )
 ;
 }
 bool
 AndroidCodecBench::isSuitableFor
 (
 Backend
 backend
 )
 {
 return
 kNonRendering_Backend
 ==
 backend
 ;
 }
 void
 AndroidCodecBench::onDelayedSetup
 (
 )
 {
 std::unique_ptr<
 kAndroidCodec>
 codec
 (
 SkAndroidCodec::MakeFromData
 (
 fData
 )
 )
 ;
 SkISize
 scaledSize
=
 codec
 -
 >
 etSampledDimensions
 (
 fSampleSize
 )
 ;
 fInfo
=
 codec
 -
 >
 etInfo
 (
 )
 (
 scaledSize.width
 (
 )
 ,
 scaledSize.height
 (
 )
 )
 (
kN32
 )
 ;
 if
 (
 kUnpremul_SkAlphaType
 ==
 fInfo.alphaType
 (
 )
 )
 {
 fInfo
=
 fInfo.makeAlphaType
 (
 kPremul_SkAlphaType
 )
 ;
 }
 fPixelStorage.reset
 (
 fInfo.computeMinByteSize
 (
 )
 )
 ;
 }
 void
 AndroidCodecBench::onDraw
 (
 int
 n
 ,
 SkCanvas
 *
 canvas
 )
 {
 std::unique_ptr<
 kAndroidCodec>
 codec
 ;
 SkAndroidCodec::AndroidOptions
 options
 ;
 options.fSampleSize
=
 fSampleSize
 ;
 for
 (
 int
 i
=
0
 ;
 i
 <
 n
 ;
 i
 +
 +
 )
 {
 codec
=
 SkAndroidCodec::MakeFromData
 (
 fData
 )
 ;
 const
 SkCodec::Result
 result
=
 codec
 -
 >
 etAndroidPixels
 (
 fInfo
 ,
 fPixelStorage.get
 (
 )
 ,
 fInfo.minRowBytes
 (
 )
 ,
 &
 options
 )
 ;
 SkASSERT
 (
 result
 ==
 SkCodec::kSuccess
 |
 |
 result
 ==
 SkCodec::kIncompleteInput
 )
 ;
 }
 }
